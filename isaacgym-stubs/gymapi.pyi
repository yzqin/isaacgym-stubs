from typing import Any, ClassVar, Dict, List, Tuple

from typing import overload
import numpy

AXIS_ALL: int
AXIS_NONE: int
AXIS_ROTATION: int
AXIS_SWING_1: int
AXIS_SWING_2: int
AXIS_TRANSLATION: int
AXIS_TWIST: int
AXIS_X: int
AXIS_Y: int
AXIS_Z: int
CC_ALL_SUBSTEPS: ContactCollection
CC_LAST_SUBSTEP: ContactCollection
CC_NEVER: ContactCollection
COMPUTE_PER_FACE: MeshNormalMode
COMPUTE_PER_VERTEX: MeshNormalMode
DEFAULT_VIEWER_HEIGHT: int
DEFAULT_VIEWER_WIDTH: int
DOF_INVALID: DofType
DOF_MODE_EFFORT: DofDriveMode
DOF_MODE_NONE: DofDriveMode
DOF_MODE_POS: DofDriveMode
DOF_MODE_VEL: DofDriveMode
DOF_ROTATION: DofType
DOF_TRANSLATION: DofType
DOMAIN_ACTOR: IndexDomain
DOMAIN_ENV: IndexDomain
DOMAIN_SIM: IndexDomain
DTYPE_FLOAT32: TensorDataType
DTYPE_INT16: TensorDataType
DTYPE_UINT32: TensorDataType
DTYPE_UINT64: TensorDataType
DTYPE_UINT8: TensorDataType
ENV_SPACE: CoordinateSpace
FOLLOW_POSITION: CameraFollowMode
FOLLOW_TRANSFORM: CameraFollowMode
FROM_ASSET: MeshNormalMode
GLOBAL_SPACE: CoordinateSpace
IMAGE_COLOR: ImageType
IMAGE_DEPTH: ImageType
IMAGE_OPTICAL_FLOW: ImageType
IMAGE_SEGMENTATION: ImageType
INVALID_HANDLE: int
JOINT_BALL: JointType
JOINT_FIXED: JointType
JOINT_FLOATING: JointType
JOINT_INVALID: JointType
JOINT_PLANAR: JointType
JOINT_PRISMATIC: JointType
JOINT_REVOLUTE: JointType
KEY_0: KeyboardInput
KEY_1: KeyboardInput
KEY_2: KeyboardInput
KEY_3: KeyboardInput
KEY_4: KeyboardInput
KEY_5: KeyboardInput
KEY_6: KeyboardInput
KEY_7: KeyboardInput
KEY_8: KeyboardInput
KEY_9: KeyboardInput
KEY_A: KeyboardInput
KEY_APOSTROPHE: KeyboardInput
KEY_B: KeyboardInput
KEY_BACKSLASH: KeyboardInput
KEY_BACKSPACE: KeyboardInput
KEY_C: KeyboardInput
KEY_CAPS_LOCK: KeyboardInput
KEY_COMMA: KeyboardInput
KEY_D: KeyboardInput
KEY_DEL: KeyboardInput
KEY_DOWN: KeyboardInput
KEY_E: KeyboardInput
KEY_END: KeyboardInput
KEY_ENTER: KeyboardInput
KEY_EQUAL: KeyboardInput
KEY_ESCAPE: KeyboardInput
KEY_F: KeyboardInput
KEY_F1: KeyboardInput
KEY_F10: KeyboardInput
KEY_F11: KeyboardInput
KEY_F12: KeyboardInput
KEY_F2: KeyboardInput
KEY_F3: KeyboardInput
KEY_F4: KeyboardInput
KEY_F5: KeyboardInput
KEY_F6: KeyboardInput
KEY_F7: KeyboardInput
KEY_F8: KeyboardInput
KEY_F9: KeyboardInput
KEY_G: KeyboardInput
KEY_GRAVE_ACCENT: KeyboardInput
KEY_H: KeyboardInput
KEY_HOME: KeyboardInput
KEY_I: KeyboardInput
KEY_INSERT: KeyboardInput
KEY_J: KeyboardInput
KEY_K: KeyboardInput
KEY_L: KeyboardInput
KEY_LEFT: KeyboardInput
KEY_LEFT_ALT: KeyboardInput
KEY_LEFT_BRACKET: KeyboardInput
KEY_LEFT_CONTROL: KeyboardInput
KEY_LEFT_SHIFT: KeyboardInput
KEY_LEFT_SUPER: KeyboardInput
KEY_M: KeyboardInput
KEY_MENU: KeyboardInput
KEY_MINUS: KeyboardInput
KEY_N: KeyboardInput
KEY_NUMPAD_0: KeyboardInput
KEY_NUMPAD_1: KeyboardInput
KEY_NUMPAD_2: KeyboardInput
KEY_NUMPAD_3: KeyboardInput
KEY_NUMPAD_4: KeyboardInput
KEY_NUMPAD_5: KeyboardInput
KEY_NUMPAD_6: KeyboardInput
KEY_NUMPAD_7: KeyboardInput
KEY_NUMPAD_8: KeyboardInput
KEY_NUMPAD_9: KeyboardInput
KEY_NUMPAD_ADD: KeyboardInput
KEY_NUMPAD_DEL: KeyboardInput
KEY_NUMPAD_DIVIDE: KeyboardInput
KEY_NUMPAD_ENTER: KeyboardInput
KEY_NUMPAD_EQUAL: KeyboardInput
KEY_NUMPAD_MULTIPLY: KeyboardInput
KEY_NUMPAD_SUBTRACT: KeyboardInput
KEY_NUM_LOCK: KeyboardInput
KEY_O: KeyboardInput
KEY_P: KeyboardInput
KEY_PAGE_DOWN: KeyboardInput
KEY_PAGE_UP: KeyboardInput
KEY_PAUSE: KeyboardInput
KEY_PERIOD: KeyboardInput
KEY_PRINT_SCREEN: KeyboardInput
KEY_Q: KeyboardInput
KEY_R: KeyboardInput
KEY_RIGHT: KeyboardInput
KEY_RIGHT_ALT: KeyboardInput
KEY_RIGHT_BRACKET: KeyboardInput
KEY_RIGHT_CONTROL: KeyboardInput
KEY_RIGHT_SHIFT: KeyboardInput
KEY_RIGHT_SUPER: KeyboardInput
KEY_S: KeyboardInput
KEY_SCROLL_LOCK: KeyboardInput
KEY_SEMICOLON: KeyboardInput
KEY_SLASH: KeyboardInput
KEY_SPACE: KeyboardInput
KEY_T: KeyboardInput
KEY_TAB: KeyboardInput
KEY_U: KeyboardInput
KEY_UP: KeyboardInput
KEY_V: KeyboardInput
KEY_W: KeyboardInput
KEY_X: KeyboardInput
KEY_Y: KeyboardInput
KEY_Z: KeyboardInput
LOCAL_SPACE: CoordinateSpace
MAT_COROTATIONAL: SoftMaterialType
MAT_NEOHOOKEAN: SoftMaterialType
MESH_COLLISION: MeshType
MESH_NONE: MeshType
MESH_VISUAL: MeshType
MESH_VISUAL_AND_COLLISION: MeshType
MOUSE_BACK_BUTTON: MouseInput
MOUSE_FORWARD_BUTTON: MouseInput
MOUSE_LEFT_BUTTON: MouseInput
MOUSE_MIDDLE_BUTTON: MouseInput
MOUSE_MOVE_DOWN: MouseInput
MOUSE_MOVE_LEFT: MouseInput
MOUSE_MOVE_RIGHT: MouseInput
MOUSE_MOVE_UP: MouseInput
MOUSE_RIGHT_BUTTON: MouseInput
MOUSE_SCROLL_DOWN: MouseInput
MOUSE_SCROLL_LEFT: MouseInput
MOUSE_SCROLL_RIGHT: MouseInput
MOUSE_SCROLL_UP: MouseInput
RIGID_BODY_DISABLE_GRAVITY: int
RIGID_BODY_DISABLE_SIMULATION: int
RIGID_BODY_NONE: int
SIM_FLEX: SimType
SIM_PHYSX: SimType
STATE_ALL: int
STATE_NONE: int
STATE_POS: int
STATE_VEL: int
TENDON_FIXED: TendonType
TENDON_SPATIAL: TendonType
UP_AXIS_Y: UpAxis
UP_AXIS_Z: UpAxis
USD_MATERIAL_DISPLAY_COLOR: UsdMaterialMode
USD_MATERIAL_MDL: UsdMaterialMode
USD_MATERIAL_PREVIEW_SURFACE: UsdMaterialMode


class ActionEvent:
    def __init__(self) -> None: ...

    @property
    def action(self) -> str: ...

    @property
    def value(self) -> float: ...


class ActuatorProperties:
    control_limited: bool
    force_limited: bool
    kp: float
    kv: float
    lower_control_limit: float
    lower_force_limit: float
    motor_effort: float
    upper_control_limit: float
    upper_force_limit: float

    def __init__(self) -> None: ...

    @property
    def type(self) -> Any: ...


class Asset:
    def __init__(self, *args, **kwargs) -> None: ...


class AssetOptions:
    angular_damping: float
    armature: float
    collapse_fixed_joints: bool
    convex_decomposition_from_submeshes: bool
    default_dof_drive_mode: int
    density: float
    disable_gravity: bool
    fix_base_link: bool
    flip_visual_attachments: bool
    linear_damping: float
    max_angular_velocity: float
    max_linear_velocity: float
    mesh_normal_mode: MeshNormalMode
    min_particle_mass: float
    override_com: bool
    override_inertia: bool
    replace_cylinder_with_capsule: bool
    slices_per_cylinder: int
    tendon_limit_stiffness: float
    thickness: float
    use_mesh_materials: bool
    use_physx_armature: bool
    vhacd_enabled: bool
    vhacd_params: VhacdParams

    def __init__(self) -> None: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class AttractorProperties:
    axes: int
    damping: float
    offset: Transform
    rigid_handle: int
    stiffness: float
    target: Transform

    def __init__(self) -> None: ...


class CameraFollowMode:
    __members__: ClassVar[dict] = ...  # read-only
    FOLLOW_POSITION: ClassVar[CameraFollowMode] = ...
    FOLLOW_TRANSFORM: ClassVar[CameraFollowMode] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class CameraProperties:
    enable_tensors: bool
    far_plane: float
    height: int
    horizontal_fov: float
    near_plane: float
    supersampling_horizontal: int
    supersampling_vertical: int
    use_collision_geometry: bool
    width: int

    def __init__(self) -> None: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class ContactCollection:
    __members__: ClassVar[dict] = ...  # read-only
    CC_ALL_SUBSTEPS: ClassVar[ContactCollection] = ...
    CC_LAST_SUBSTEP: ClassVar[ContactCollection] = ...
    CC_NEVER: ClassVar[ContactCollection] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    @property
    def name(self) -> str: ...


class CoordinateSpace:
    __members__: ClassVar[dict] = ...  # read-only
    ENV_SPACE: ClassVar[CoordinateSpace] = ...
    GLOBAL_SPACE: ClassVar[CoordinateSpace] = ...
    LOCAL_SPACE: ClassVar[CoordinateSpace] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    @property
    def name(self) -> str: ...


class DofDriveMode:
    __members__: ClassVar[dict] = ...  # read-only
    DOF_MODE_EFFORT: ClassVar[DofDriveMode] = ...
    DOF_MODE_NONE: ClassVar[DofDriveMode] = ...
    DOF_MODE_POS: ClassVar[DofDriveMode] = ...
    DOF_MODE_VEL: ClassVar[DofDriveMode] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class DofFrame:
    dtype: ClassVar[dtype] = ...  # read-only
    axis: Vec3
    origin: Vec3

    def __init__(self, origin: Vec3 = ..., axis: Vec3 = ...) -> None: ...

    def from_buffer(self, *args, **kwargs) -> Any: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class DofState:
    dtype: ClassVar[dtype] = ...  # read-only
    pos: float
    vel: float

    def __init__(self, *args, **kwargs) -> None: ...


class DofType:
    __members__: ClassVar[dict] = ...  # read-only
    DOF_INVALID: ClassVar[DofType] = ...
    DOF_ROTATION: ClassVar[DofType] = ...
    DOF_TRANSLATION: ClassVar[DofType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class Env:
    def __init__(self, *args, **kwargs) -> None: ...


class FlexParams:
    contact_regularization: float
    deterministic_mode: bool
    dynamic_friction: float
    friction_mode: int
    geometric_stiffness: float
    max_rigid_contacts: int
    max_soft_contacts: int
    num_inner_iterations: int
    num_outer_iterations: int
    particle_friction: float
    relaxation: float
    return_contacts: bool
    shape_collision_distance: float
    shape_collision_margin: float
    solver_type: int
    static_friction: float
    warm_start: float

    def __init__(self) -> None: ...


class ForceSensor:
    def __init__(self) -> None: ...

    def get_forces(self) -> SpatialForce: ...

    def get_global_index(self) -> int: ...


class ForceSensorProperties:
    enable_constraint_solver_forces: bool
    enable_forward_dynamics_forces: bool
    use_world_frame: bool

    def __init__(self) -> None: ...


class Gym:
    def __init__(self, *args, **kwargs) -> None: ...

    def acquire_actor_root_state_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_dof_force_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_dof_state_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_force_sensor_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_jacobian_tensor(self, arg0: Sim, arg1: str) -> Tensor: ...

    def acquire_mass_matrix_tensor(self, arg0: Sim, arg1: str) -> Tensor: ...

    def acquire_net_contact_force_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_particle_state_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_pneumatic_pressure_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_pneumatic_target_tensor(self, arg0: Sim) -> Tensor: ...

    def acquire_rigid_body_state_tensor(self, arg0: Sim) -> Tensor: ...

    def add_ground(self, sim: Sim, params: PlaneParams) -> None: ...

    def add_heightfield(self, arg0: Sim, arg1: numpy.ndarray[int16], arg2: HeightFieldParams) -> None: ...

    @overload
    def add_lines(self, arg0: Viewer, arg1: Env, arg2: int, arg3: numpy.ndarray[float32],
                  arg4: numpy.ndarray[float32]) -> None: ...

    @overload
    def add_lines(self, arg0: Viewer, arg1: Env, arg2: int, arg3: numpy.ndarray[Vec3],
                  arg4: numpy.ndarray[Vec3]) -> None: ...

    def add_triangle_mesh(self, arg0: Sim, arg1: numpy.ndarray[float32], arg2: numpy.ndarray[uint32],
                          arg3: TriangleMeshParams) -> None: ...

    def apply_actor_dof_efforts(self, arg0: Env, arg1: int, arg2: numpy.ndarray[float32]) -> bool: ...

    def apply_body_force_at_pos(self, env: Env, rigidHandle: int, force: Vec3, pos: Vec3 = ...,
                                space: CoordinateSpace = ...) -> None: ...

    def apply_body_forces(self, env: Env, rigidHandle: int, force: Vec3 = ..., torque: Vec3 = ...,
                          space: CoordinateSpace = ...) -> None: ...

    def apply_dof_effort(self, arg0: Env, arg1: int, arg2: float) -> None: ...

    def apply_rigid_body_force_at_pos_tensors(self, sim: Sim, forceTensor: Tensor, posTensor: Tensor = ...,
                                              space: CoordinateSpace = ...) -> bool: ...

    def apply_rigid_body_force_tensors(self, sim: Sim, forceTensor: Tensor = ..., torqueTensor: Tensor = ...,
                                       space: CoordinateSpace = ...) -> bool: ...

    def attach_camera_to_body(self, arg0: int, arg1: Env, arg2: int, arg3: Transform,
                              arg4: CameraFollowMode) -> None: ...

    def attach_sim(self, arg0: int, arg1: int, arg2: SimType, arg3: str, arg4: str) -> Sim: ...

    def begin_aggregate(self, arg0: Env, arg1: int, arg2: int, arg3: bool) -> bool: ...

    def clear_lines(self, arg0: Viewer) -> None: ...

    def create_actor(self, env: Env, asset: Asset, pose: Transform, name: str = ..., group: int = ...,
                     filter: int = ..., segmentationId: int = ...) -> int: ...

    def create_aggregate(self, arg0: Env, arg1: List[int]) -> bool: ...

    def create_asset_force_sensor(self, *args, **kwargs) -> Any: ...

    def create_box(self, sim: Sim, width: float, height: float, depth: float, options: AssetOptions = ...) -> Asset: ...

    def create_camera_sensor(self, arg0: Env, arg1: CameraProperties) -> int: ...

    def create_capsule(self, sim: Sim, radius: float, width: float, options: AssetOptions = ...) -> Asset: ...

    def create_cloth_grid(self, arg0: Sim, arg1: int, arg2: int, arg3: float, arg4: float) -> Asset: ...

    def create_env(self, arg0: Sim, arg1: Vec3, arg2: Vec3, arg3: int) -> Env: ...

    def create_performance_timers(self, arg0: Sim) -> int: ...

    def create_rigid_body_attractor(self, arg0: Env, arg1: AttractorProperties) -> int: ...

    def create_sim(self, compute_device: int = ..., graphics_device: int = ..., type: SimType = ...,
                   params: SimParams = ...) -> Sim: ...

    def create_sphere(self, sim: Sim, radius: float, options: AssetOptions = ...) -> Asset: ...

    @overload
    def create_tet_grid(self, arg0: Sim, arg1: SoftMaterial, arg2: int, arg3: int, arg4: int, arg5: float, arg6: float,
                        arg7: float, arg8: float, arg9: bool, arg10: bool, arg11: bool, arg12: bool) -> Asset: ...

    @overload
    def create_tet_grid(self, arg0: Sim, arg1: SoftMaterial, arg2: int, arg3: int, arg4: int, arg5: float, arg6: float,
                        arg7: float, arg8: float, arg9: bool, arg10: bool, arg11: bool, arg12: bool) -> Asset: ...

    def create_texture_from_buffer(self, arg0: Sim, arg1: int, arg2: int, arg3: numpy.ndarray[uint8]) -> int: ...

    def create_texture_from_file(self, arg0: Sim, arg1: str) -> int: ...

    def create_usd_exporter(self, options: UsdExportOptions = ...) -> UsdExporter: ...

    def create_viewer(self, arg0: Sim, arg1: CameraProperties) -> Viewer: ...

    def debug_print_asset(self, asset: Asset, outpath: str = ...) -> None: ...

    def destroy_camera_sensor(self, arg0: Sim, arg1: Env, arg2: int) -> None: ...

    def destroy_env(self, arg0: Env) -> None: ...

    def destroy_performance_timers(self, arg0: Sim, arg1: int) -> None: ...

    def destroy_sim(self, arg0: Sim) -> None: ...

    def destroy_usd_exporter(self, arg0: UsdExporter) -> None: ...

    def destroy_viewer(self, arg0: Viewer) -> None: ...

    def draw_env_rigid_contacts(self, arg0: Viewer, arg1: Env, arg2: Vec3, arg3: float, arg4: bool) -> None: ...

    def draw_env_soft_contacts(self, arg0: Viewer, arg1: Env, arg2: Vec3, arg3: float, arg4: bool,
                               arg5: bool) -> None: ...

    def draw_viewer(self, viewer: Viewer, sim: Sim, render_collision: bool = ...) -> None: ...

    def enable_actor_dof_force_sensors(self, arg0: Env, arg1: int) -> bool: ...

    def end_access_image_tensors(self, arg0: Sim) -> None: ...

    def end_aggregate(self, arg0: Env) -> bool: ...

    def export_usd_asset(self, arg0: UsdExporter, arg1: Asset, arg2: str) -> bool: ...

    def export_usd_sim(self, exporter: UsdExporter, sim: Sim, name: str, dirName: str = ...) -> object: ...

    def fetch_results(self, arg0: Sim, arg1: bool) -> None: ...

    def find_actor_actuator_index(self, arg0: Env, arg1: int, arg2: str) -> int: ...

    def find_actor_dof_handle(self, arg0: Env, arg1: int, arg2: str) -> int: ...

    def find_actor_dof_index(self, arg0: Env, arg1: int, arg2: str, arg3: IndexDomain) -> int: ...

    def find_actor_fixed_tendon_joint_index(self, arg0: Env, arg1: int, arg2: int, arg3: str) -> int: ...

    def find_actor_handle(self, arg0: Env, arg1: str) -> int: ...

    def find_actor_index(self, arg0: Env, arg1: str, arg2: IndexDomain) -> int: ...

    def find_actor_joint_handle(self, arg0: Env, arg1: int, arg2: str) -> int: ...

    def find_actor_joint_index(self, arg0: Env, arg1: int, arg2: str, arg3: IndexDomain) -> int: ...

    def find_actor_rigid_body_handle(self, arg0: Env, arg1: int, arg2: str) -> int: ...

    def find_actor_rigid_body_index(self, arg0: Env, arg1: int, arg2: str, arg3: IndexDomain) -> int: ...

    def find_actor_tendon_index(self, arg0: Env, arg1: int, arg2: str) -> int: ...

    def find_asset_actuator_index(self, arg0: Asset, arg1: str) -> int: ...

    def find_asset_dof_index(self, arg0: Asset, arg1: str) -> int: ...

    def find_asset_joint_index(self, arg0: Asset, arg1: str) -> int: ...

    def find_asset_rigid_body_index(self, arg0: Asset, arg1: str) -> int: ...

    def find_asset_tendon_index(self, arg0: Asset, arg1: str) -> int: ...

    def free_texture(self, arg0: Sim, arg1: int) -> None: ...

    def get_actor_actuator_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_actuator_joint_name(self, arg0: Env, arg1: int, arg2: int) -> str: ...

    def get_actor_actuator_name(self, arg0: Env, arg1: int, arg2: int) -> str: ...

    def get_actor_actuator_properties(self, arg0: Env, arg1: int) -> List[ActuatorProperties]: ...

    def get_actor_asset(self, arg0: Env, arg1: int) -> Asset: ...

    def get_actor_count(self, arg0: Env) -> int: ...

    def get_actor_dof_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_dof_dict(self, arg0: Env, arg1: int) -> Dict[str, int]: ...

    def get_actor_dof_forces(self, arg0: Env, arg1: int) -> numpy.ndarray[numpy.float32]: ...

    def get_actor_dof_frames(self, arg0: Env, arg1: int) -> numpy.ndarray[DofFrame]: ...

    def get_actor_dof_handle(self, arg0: Env, arg1: int, arg2: int) -> int: ...

    def get_actor_dof_index(self, arg0: Env, arg1: int, arg2: int, arg3: IndexDomain) -> int: ...

    def get_actor_dof_names(self, arg0: Env, arg1: int) -> List[str]: ...

    def get_actor_dof_position_targets(self, *args, **kwargs) -> Any: ...

    def get_actor_dof_properties(self, *args, **kwargs) -> Any: ...

    def get_actor_dof_states(self, *args, **kwargs) -> Any: ...

    def get_actor_dof_velocity_targets(self, *args, **kwargs) -> Any: ...

    def get_actor_fixed_tendon_joint_coefficients(self, arg0: Env, arg1: int, arg2: int) -> List[float]: ...

    def get_actor_fixed_tendon_joint_name(self, arg0: Env, arg1: int, arg2: int, arg3: int) -> str: ...

    def get_actor_force_sensor(self, arg0: Env, arg1: int, arg2: int) -> ForceSensor: ...

    def get_actor_force_sensor_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_handle(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_index(self, arg0: Env, arg1: int, arg2: IndexDomain) -> int: ...

    def get_actor_joint_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_joint_dict(self, arg0: Env, arg1: int) -> Dict[str, int]: ...

    def get_actor_joint_handle(self, arg0: Env, arg1: int, arg2: int) -> int: ...

    def get_actor_joint_index(self, arg0: Env, arg1: int, arg2: int, arg3: IndexDomain) -> int: ...

    def get_actor_joint_names(self, arg0: Env, arg1: int) -> List[str]: ...

    def get_actor_joint_transforms(self, arg0: Env, arg1: int) -> numpy.ndarray[Transform]: ...

    def get_actor_name(self, arg0: Env, arg1: int) -> str: ...

    def get_actor_rigid_body_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_rigid_body_dict(self, arg0: Env, arg1: int) -> Dict[str, int]: ...

    def get_actor_rigid_body_handle(self, arg0: Env, arg1: int, arg2: int) -> int: ...

    def get_actor_rigid_body_index(self, arg0: Env, arg1: int, arg2: int, arg3: IndexDomain) -> int: ...

    def get_actor_rigid_body_names(self, arg0: Env, arg1: int) -> List[str]: ...

    def get_actor_rigid_body_properties(self, arg0: Env, arg1: int) -> List[RigidBodyProperties]: ...

    def get_actor_rigid_body_shape_indices(self, arg0: Env, arg1: int) -> List[IndexRange]: ...

    def get_actor_rigid_body_states(self, arg0: Env, arg1: int, arg2: int) -> numpy.ndarray[RigidBodyState]: ...

    def get_actor_rigid_shape_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_rigid_shape_properties(self, arg0: Env, arg1: int) -> List[RigidShapeProperties]: ...

    def get_actor_root_rigid_body_handle(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_scale(self, arg0: Env, arg1: int) -> float: ...

    def get_actor_soft_body_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_soft_materials(self, arg0: Env, arg1: int) -> List[SoftMaterial]: ...

    def get_actor_tendon_count(self, arg0: Env, arg1: int) -> int: ...

    def get_actor_tendon_name(self, arg0: Env, arg1: int, arg2: int) -> str: ...

    def get_actor_tendon_offset(self, arg0: Env, arg1: int, arg2: int) -> float: ...

    def get_actor_tendon_properties(self, arg0: Env, arg1: int) -> List[TendonProperties]: ...

    def get_actor_tetrahedra_range(self, arg0: Env, arg1: int, arg2: int) -> IndexRange: ...

    def get_actor_triangle_range(self, arg0: Env, arg1: int, arg2: int) -> IndexRange: ...

    def get_asset_actuator_count(self, arg0: Asset) -> int: ...

    def get_asset_actuator_joint_name(self, arg0: Asset, arg1: int) -> str: ...

    def get_asset_actuator_name(self, arg0: Asset, arg1: int) -> str: ...

    def get_asset_actuator_properties(self, arg0: Asset) -> List[ActuatorProperties]: ...

    def get_asset_dof_count(self, arg0: Asset) -> int: ...

    def get_asset_dof_dict(self, arg0: Asset) -> Dict[str, int]: ...

    def get_asset_dof_name(self, arg0: Asset, arg1: int) -> str: ...

    def get_asset_dof_names(self, arg0: Asset) -> List[str]: ...

    def get_asset_dof_properties(self, *args, **kwargs) -> Any: ...

    def get_asset_dof_type(self, arg0: Asset, arg1: int) -> DofType: ...

    def get_asset_fixed_tendon_joint_coefficients(self, arg0: Asset, arg1: int) -> List[float]: ...

    def get_asset_fixed_tendon_joint_name(self, arg0: Asset, arg1: int, arg2: int) -> str: ...

    def get_asset_joint_count(self, arg0: Asset) -> int: ...

    def get_asset_joint_dict(self, arg0: Asset) -> Dict[str, int]: ...

    def get_asset_joint_name(self, arg0: Asset, arg1: int) -> str: ...

    def get_asset_joint_names(self, arg0: Asset) -> List[str]: ...

    def get_asset_joint_type(self, arg0: Asset, arg1: int) -> JointType: ...

    def get_asset_rigid_body_count(self, arg0: Asset) -> int: ...

    def get_asset_rigid_body_dict(self, arg0: Asset) -> Dict[str, int]: ...

    def get_asset_rigid_body_name(self, arg0: Asset, arg1: int) -> str: ...

    def get_asset_rigid_body_names(self, arg0: Asset) -> List[str]: ...

    def get_asset_rigid_body_shape_indices(self, arg0: Asset) -> List[IndexRange]: ...

    def get_asset_rigid_shape_count(self, arg0: Asset) -> int: ...

    def get_asset_rigid_shape_properties(self, arg0: Asset) -> List[RigidShapeProperties]: ...

    def get_asset_soft_body_count(self, arg0: Asset) -> int: ...

    def get_asset_soft_materials(self, arg0: Asset) -> List[SoftMaterial]: ...

    def get_asset_tendon_count(self, arg0: Asset) -> int: ...

    def get_asset_tendon_name(self, arg0: Asset, arg1: int) -> str: ...

    def get_asset_tendon_properties(self, arg0: Asset) -> List[TendonProperties]: ...

    def get_attractor_properties(self, arg0: Env, arg1: int) -> AttractorProperties: ...

    def get_camera_image(self, arg0: Sim, arg1: Env, arg2: int, arg3: ImageType) -> object: ...

    def get_camera_image_gpu_tensor(self, arg0: Sim, arg1: Env, arg2: int, arg3: ImageType) -> object: ...

    def get_camera_proj_matrix(self, arg0: Sim, arg1: Env, arg2: int) -> numpy.ndarray[numpy.float32]: ...

    def get_camera_transform(self, arg0: Sim, arg1: Env, arg2: int) -> Transform: ...

    def get_camera_view_matrix(self, arg0: Sim, arg1: Env, arg2: int) -> numpy.ndarray[numpy.float32]: ...

    def get_dof_frame(self, arg0: Env, arg1: int) -> DofFrame: ...

    def get_dof_position(self, arg0: Env, arg1: int) -> float: ...

    def get_dof_target_position(self, arg0: Env, arg1: int) -> float: ...

    def get_dof_target_velocity(self, arg0: Env, arg1: int) -> float: ...

    def get_dof_type_string(self, arg0: DofType) -> str: ...

    def get_dof_velocity(self, arg0: Env, arg1: int) -> float: ...

    def get_elapsed_time(self, arg0: Sim) -> float: ...

    def get_env(self, arg0: Sim, arg1: int) -> Env: ...

    def get_env_count(self, arg0: Sim) -> int: ...

    def get_env_dof_count(self, arg0: Env) -> int: ...

    def get_env_joint_count(self, arg0: Env) -> int: ...

    def get_env_origin(self, arg0: Env) -> Vec3: ...

    def get_env_rigid_body_count(self, arg0: Env) -> int: ...

    def get_env_rigid_body_states(self, arg0: Env, arg1: int) -> numpy.ndarray[RigidBodyState]: ...

    def get_env_rigid_contact_forces(self, arg0: Env) -> numpy.ndarray[Vec3]: ...

    def get_env_rigid_contacts(self, arg0: Env) -> numpy.ndarray[RigidContact]: ...

    def get_frame_count(self, arg0: Sim) -> int: ...

    def get_joint_handle(self, arg0: Env, arg1: str, arg2: str) -> int: ...

    def get_joint_name(self, arg0: Env, arg1: int) -> str: ...

    def get_joint_position(self, arg0: Env, arg1: int) -> float: ...

    def get_joint_target_position(self, arg0: Env, arg1: int) -> float: ...

    def get_joint_target_velocity(self, arg0: Env, arg1: int) -> float: ...

    def get_joint_transform(self, arg0: Env, arg1: int) -> Transform: ...

    def get_joint_type_string(self, arg0: JointType) -> str: ...

    def get_joint_velocity(self, arg0: Env, arg1: int) -> float: ...

    def get_performance_timers(self, arg0: Sim, arg1: int) -> PerformanceTimers: ...

    def get_pneumatic_pressure(self, arg0: Env, arg1: int, arg2: int) -> float: ...

    def get_pneumatic_target(self, arg0: Env, arg1: int, arg2: int) -> float: ...

    def get_rigid_angular_velocity(self, arg0: Env, arg1: int) -> Vec3: ...

    def get_rigid_body_color(self, arg0: Env, arg1: int, arg2: int, arg3: MeshType) -> Vec3: ...

    def get_rigid_body_segmentation_id(self, arg0: Env, arg1: int, arg2: int) -> int: ...

    def get_rigid_body_texture(self, arg0: Env, arg1: int, arg2: int, arg3: MeshType) -> int: ...

    def get_rigid_contact_forces(self, arg0: Sim) -> numpy.ndarray[Vec3]: ...

    def get_rigid_contacts(self, arg0: Sim) -> numpy.ndarray[RigidContact]: ...

    def get_rigid_handle(self, arg0: Env, arg1: str, arg2: str) -> int: ...

    def get_rigid_linear_velocity(self, arg0: Env, arg1: int) -> Vec3: ...

    def get_rigid_name(self, arg0: Env, arg1: int) -> str: ...

    def get_rigid_transform(self, arg0: Env, arg1: int) -> Transform: ...

    def get_sensor(self, arg0: Env, arg1: int) -> int: ...

    def get_sim_actor_count(self, arg0: Sim) -> int: ...

    def get_sim_dof_count(self, arg0: Sim) -> int: ...

    def get_sim_force_sensor_count(self, arg0: Sim) -> int: ...

    def get_sim_joint_count(self, arg0: Sim) -> int: ...

    def get_sim_params(self, arg0: Sim) -> object: ...

    def get_sim_rigid_body_count(self, arg0: Sim) -> int: ...

    def get_sim_rigid_body_states(self, arg0: Sim, arg1: int) -> numpy.ndarray[RigidBodyState]: ...

    def get_sim_tetrahedra(self, arg0: Sim) -> Tuple[List[int], List[Mat33]]: ...

    def get_sim_tetrahedra_count(self, arg0: Sim) -> int: ...

    def get_sim_time(self, arg0: Sim) -> float: ...

    def get_sim_triangle_count(self, arg0: Sim) -> int: ...

    def get_sim_triangles(self, arg0: Sim) -> Tuple[List[int], List[int], List[Vec3]]: ...

    def get_soft_contacts(self, arg0: Sim) -> numpy.ndarray[SoftContact]: ...

    def get_usd_export_root(self, arg0: UsdExporter) -> str: ...

    def get_vec_actor_dof_states(self, *args, **kwargs) -> Any: ...

    def get_vec_env_rigid_contact_forces(self, arg0: List[Env]) -> numpy.ndarray[Vec3]: ...

    @overload
    def get_vec_rigid_angular_velocity(self, arg0: List[Env], arg1: int) -> numpy.ndarray[Vec3]: ...

    @overload
    def get_vec_rigid_angular_velocity(self, arg0: List[Env], arg1: List[int]) -> numpy.ndarray[Vec3]: ...

    @overload
    def get_vec_rigid_linear_velocity(self, arg0: List[Env], arg1: int) -> numpy.ndarray[Vec3]: ...

    @overload
    def get_vec_rigid_linear_velocity(self, arg0: List[Env], arg1: List[int]) -> numpy.ndarray[Vec3]: ...

    @overload
    def get_vec_rigid_transform(self, arg0: List[Env], arg1: int) -> numpy.ndarray[Transform]: ...

    @overload
    def get_vec_rigid_transform(self, arg0: List[Env], arg1: List[int]) -> numpy.ndarray[Transform]: ...

    def get_version(self) -> Version: ...

    def get_viewer_camera_handle(self, arg0: Viewer) -> int: ...

    def get_viewer_camera_transform(self, arg0: Viewer, arg1: Env) -> Transform: ...

    def get_viewer_mouse_position(self, arg0: Viewer) -> Vec2: ...

    def get_viewer_size(self, arg0: Viewer) -> Int2: ...

    def load_asset(self, sim: Sim, rootpath: str, filename: str, options: AssetOptions = ...) -> Asset: ...

    def load_mjcf(self, sim: Sim, rootpath: str, filename: str, options: AssetOptions = ...) -> Asset: ...

    def load_opensim(self, sim: Sim, rootpath: str, filename: str, options: AssetOptions = ...) -> Asset: ...

    def load_sim(self, arg0: int, arg1: int, arg2: SimType, arg3: str, arg4: str) -> Sim: ...

    def load_urdf(self, sim: Sim, rootpath: str, filename: str, options: AssetOptions = ...) -> Asset: ...

    def load_usd(self, sim: Sim, rootpath: str, filename: str, options: AssetOptions = ...) -> Asset: ...

    def omni_connect(self, arg0: OmniConnectionParams) -> bool: ...

    def omni_disconnect(self) -> None: ...

    def poll_viewer_events(self, arg0: Viewer) -> None: ...

    def prepare_sim(self, arg0: Sim) -> bool: ...

    def query_viewer_action_events(self, arg0: Viewer) -> List[ActionEvent]: ...

    def query_viewer_has_closed(self, arg0: Viewer) -> bool: ...

    def refresh_actor_root_state_tensor(self, arg0: Sim) -> bool: ...

    def refresh_dof_force_tensor(self, arg0: Sim) -> bool: ...

    def refresh_dof_state_tensor(self, arg0: Sim) -> bool: ...

    def refresh_force_sensor_tensor(self, arg0: Sim) -> bool: ...

    def refresh_jacobian_tensors(self, arg0: Sim) -> bool: ...

    def refresh_mass_matrix_tensors(self, arg0: Sim) -> bool: ...

    def refresh_net_contact_force_tensor(self, arg0: Sim) -> bool: ...

    def refresh_particle_state_tensor(self, arg0: Sim) -> bool: ...

    def refresh_pneumatic_pressure_tensor(self, arg0: Sim) -> bool: ...

    def refresh_pneumatic_target_tensor(self, arg0: Sim) -> bool: ...

    def refresh_rigid_body_state_tensor(self, arg0: Sim) -> bool: ...

    def render_all_camera_sensors(self, arg0: Sim) -> None: ...

    def reset_actor_materials(self, arg0: Env, arg1: int, arg2: MeshType) -> None: ...

    def reset_actor_particles_to_rest(self, arg0: Env, arg1: int) -> bool: ...

    def set_actor_dof_position_targets(self, *args, **kwargs) -> Any: ...

    def set_actor_dof_properties(self, arg0: Env, arg1: int, arg2) -> bool: ...

    def set_actor_dof_states(self, arg0: Env, arg1: int, arg2: numpy.ndarray[DofState], arg3: int) -> bool: ...

    def set_actor_dof_velocity_targets(self, *args, **kwargs) -> Any: ...

    def set_actor_fixed_tendon_joint_coefficients(self, arg0: Env, arg1: int, arg2: int, arg3: List[float]) -> bool: ...

    def set_actor_rigid_body_properties(self, env: Env, actorHandle: int, props: List[RigidBodyProperties],
                                        recomputeInertia: bool = ...) -> bool: ...

    def set_actor_rigid_body_states(self, arg0: Env, arg1: int, arg2: numpy.ndarray[RigidBodyState],
                                    arg3: int) -> bool: ...

    def set_actor_rigid_shape_properties(self, arg0: Env, arg1: int, arg2: List[RigidShapeProperties]) -> bool: ...

    def set_actor_root_state_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_actor_root_state_tensor_indexed(self, arg0: Sim, arg1: Tensor, arg2: Tensor, arg3: int) -> bool: ...

    def set_actor_scale(self, arg0: Env, arg1: int, arg2: float) -> bool: ...

    def set_actor_soft_materials(self, arg0: Env, arg1: int, arg2: List[SoftMaterial]) -> bool: ...

    def set_actor_tendon_offset(self, arg0: Env, arg1: int, arg2: int, arg3: float) -> bool: ...

    def set_actor_tendon_properties(self, arg0: Env, arg1: int, arg2: List[TendonProperties]) -> bool: ...

    def set_asset_fixed_tendon_joint_coefficients(self, arg0: Asset, arg1: int, arg2: List[float]) -> bool: ...

    def set_asset_rigid_shape_properties(self, arg0: Asset, arg1: List[RigidShapeProperties]) -> bool: ...

    def set_asset_tendon_properties(self, arg0: Asset, arg1: List[TendonProperties]) -> bool: ...

    def set_attractor_properties(self, arg0: Env, arg1: int, arg2: AttractorProperties) -> None: ...

    def set_attractor_target(self, arg0: Env, arg1: int, arg2: Transform) -> None: ...

    def set_camera_location(self, arg0: int, arg1: Env, arg2: Vec3, arg3: Vec3) -> None: ...

    def set_camera_transform(self, arg0: int, arg1: Env, arg2: Transform) -> None: ...

    def set_dof_actuation_force_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_dof_actuation_force_tensor_indexed(self, arg0: Sim, arg1: Tensor, arg2: Tensor, arg3: int) -> bool: ...

    def set_dof_position_target_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_dof_position_target_tensor_indexed(self, arg0: Sim, arg1: Tensor, arg2: Tensor, arg3: int) -> bool: ...

    def set_dof_state_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_dof_state_tensor_indexed(self, arg0: Sim, arg1: Tensor, arg2: Tensor, arg3: int) -> bool: ...

    def set_dof_target_position(self, arg0: Env, arg1: int, arg2: float) -> None: ...

    def set_dof_target_velocity(self, arg0: Env, arg1: int, arg2: float) -> None: ...

    def set_dof_velocity_target_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_dof_velocity_target_tensor_indexed(self, arg0: Sim, arg1: Tensor, arg2: Tensor, arg3: int) -> bool: ...

    def set_env_rigid_body_states(self, arg0: Env, arg1: numpy.ndarray[RigidBodyState], arg2: int) -> bool: ...

    def set_joint_target_position(self, arg0: Env, arg1: int, arg2: float) -> None: ...

    def set_joint_target_velocity(self, arg0: Env, arg1: int, arg2: float) -> None: ...

    def set_light_parameters(self, arg0: Sim, arg1: int, arg2: Vec3, arg3: Vec3, arg4: Vec3) -> None: ...

    def set_particle_state_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_particle_state_tensor_indexed(self, arg0: Sim, arg1: Tensor, arg2: Tensor, arg3: int) -> bool: ...

    def set_pneumatic_pressure(self, arg0: Env, arg1: int, arg2: int, arg3: float) -> None: ...

    def set_pneumatic_pressure_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_pneumatic_pressure_tensor_indexed(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_pneumatic_target(self, arg0: Env, arg1: int, arg2: int, arg3: float) -> None: ...

    def set_pneumatic_target_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_pneumatic_target_tensor_indexed(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_rigid_angular_velocity(self, arg0: Env, arg1: int, arg2: Vec3) -> None: ...

    def set_rigid_body_color(self, arg0: Env, arg1: int, arg2: int, arg3: MeshType, arg4: Vec3) -> None: ...

    def set_rigid_body_segmentation_id(self, arg0: Env, arg1: int, arg2: int, arg3: int) -> None: ...

    def set_rigid_body_state_tensor(self, arg0: Sim, arg1: Tensor) -> bool: ...

    def set_rigid_body_texture(self, arg0: Env, arg1: int, arg2: int, arg3: MeshType, arg4: int) -> None: ...

    def set_rigid_linear_velocity(self, *args, **kwargs) -> Any: ...

    def set_rigid_transform(self, *args, **kwargs) -> Any: ...

    def set_sim_device(self, arg0: Sim) -> None: ...

    def set_sim_params(self, arg0: Sim, arg1: SimParams) -> None: ...

    def set_sim_rigid_body_states(self, arg0: Sim, arg1: numpy.ndarray[RigidBodyState], arg2: int) -> bool: ...

    def set_usd_export_root(self, arg0: UsdExporter, arg1: str) -> bool: ...

    def simulate(self, arg0: Sim) -> None: ...

    def start_access_image_tensors(self, arg0: Sim) -> None: ...

    def step_graphics(self, arg0: Sim) -> None: ...

    def subscribe_viewer_keyboard_event(self, arg0: Viewer, arg1: KeyboardInput, arg2: str) -> None: ...

    def subscribe_viewer_mouse_event(self, arg0: Viewer, arg1: MouseInput, arg2: str) -> None: ...

    def sync_frame_time(self, arg0: Sim) -> None: ...

    def viewer_camera_look_at(self, arg0: Viewer, arg1: Env, arg2: Vec3, arg3: Vec3) -> None: ...

    def write_camera_image_to_file(self, arg0: Sim, arg1: Env, arg2: int, arg3: ImageType, arg4: str) -> None: ...

    def write_viewer_image_to_file(self, arg0: Viewer, arg1: str) -> None: ...


class HeightFieldParams:
    column_scale: float
    dynamic_friction: float
    nbColumns: int
    nbRows: int
    restitution: float
    row_scale: float
    segmentation_id: int
    static_friction: float
    transform: Transform
    vertical_scale: float

    def __init__(self) -> None: ...


class ImageType:
    __members__: ClassVar[dict] = ...  # read-only
    IMAGE_COLOR: ClassVar[ImageType] = ...
    IMAGE_DEPTH: ClassVar[ImageType] = ...
    IMAGE_OPTICAL_FLOW: ClassVar[ImageType] = ...
    IMAGE_SEGMENTATION: ClassVar[ImageType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class IndexDomain:
    __members__: ClassVar[dict] = ...  # read-only
    DOMAIN_ACTOR: ClassVar[IndexDomain] = ...
    DOMAIN_ENV: ClassVar[IndexDomain] = ...
    DOMAIN_SIM: ClassVar[IndexDomain] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    @property
    def name(self) -> str: ...


class IndexRange:
    count: int
    start: int

    def __init__(self) -> None: ...


class Int2:
    dtype: ClassVar[dtype] = ...  # read-only
    x: int
    y: int

    def __init__(self, x: int = ..., y: int = ...) -> None: ...


class Int3:
    dtype: ClassVar[dtype] = ...  # read-only
    x: int
    y: int
    z: int

    def __init__(self, x: int = ..., y: int = ..., z: int = ...) -> None: ...


class JointType:
    __members__: ClassVar[dict] = ...  # read-only
    JOINT_BALL: ClassVar[JointType] = ...
    JOINT_FIXED: ClassVar[JointType] = ...
    JOINT_FLOATING: ClassVar[JointType] = ...
    JOINT_INVALID: ClassVar[JointType] = ...
    JOINT_PLANAR: ClassVar[JointType] = ...
    JOINT_PRISMATIC: ClassVar[JointType] = ...
    JOINT_REVOLUTE: ClassVar[JointType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class KeyboardInput:
    __members__: ClassVar[dict] = ...  # read-only
    KEY_0: ClassVar[KeyboardInput] = ...
    KEY_1: ClassVar[KeyboardInput] = ...
    KEY_2: ClassVar[KeyboardInput] = ...
    KEY_3: ClassVar[KeyboardInput] = ...
    KEY_4: ClassVar[KeyboardInput] = ...
    KEY_5: ClassVar[KeyboardInput] = ...
    KEY_6: ClassVar[KeyboardInput] = ...
    KEY_7: ClassVar[KeyboardInput] = ...
    KEY_8: ClassVar[KeyboardInput] = ...
    KEY_9: ClassVar[KeyboardInput] = ...
    KEY_A: ClassVar[KeyboardInput] = ...
    KEY_APOSTROPHE: ClassVar[KeyboardInput] = ...
    KEY_B: ClassVar[KeyboardInput] = ...
    KEY_BACKSLASH: ClassVar[KeyboardInput] = ...
    KEY_BACKSPACE: ClassVar[KeyboardInput] = ...
    KEY_C: ClassVar[KeyboardInput] = ...
    KEY_CAPS_LOCK: ClassVar[KeyboardInput] = ...
    KEY_COMMA: ClassVar[KeyboardInput] = ...
    KEY_D: ClassVar[KeyboardInput] = ...
    KEY_DEL: ClassVar[KeyboardInput] = ...
    KEY_DOWN: ClassVar[KeyboardInput] = ...
    KEY_E: ClassVar[KeyboardInput] = ...
    KEY_END: ClassVar[KeyboardInput] = ...
    KEY_ENTER: ClassVar[KeyboardInput] = ...
    KEY_EQUAL: ClassVar[KeyboardInput] = ...
    KEY_ESCAPE: ClassVar[KeyboardInput] = ...
    KEY_F: ClassVar[KeyboardInput] = ...
    KEY_F1: ClassVar[KeyboardInput] = ...
    KEY_F10: ClassVar[KeyboardInput] = ...
    KEY_F11: ClassVar[KeyboardInput] = ...
    KEY_F12: ClassVar[KeyboardInput] = ...
    KEY_F2: ClassVar[KeyboardInput] = ...
    KEY_F3: ClassVar[KeyboardInput] = ...
    KEY_F4: ClassVar[KeyboardInput] = ...
    KEY_F5: ClassVar[KeyboardInput] = ...
    KEY_F6: ClassVar[KeyboardInput] = ...
    KEY_F7: ClassVar[KeyboardInput] = ...
    KEY_F8: ClassVar[KeyboardInput] = ...
    KEY_F9: ClassVar[KeyboardInput] = ...
    KEY_G: ClassVar[KeyboardInput] = ...
    KEY_GRAVE_ACCENT: ClassVar[KeyboardInput] = ...
    KEY_H: ClassVar[KeyboardInput] = ...
    KEY_HOME: ClassVar[KeyboardInput] = ...
    KEY_I: ClassVar[KeyboardInput] = ...
    KEY_INSERT: ClassVar[KeyboardInput] = ...
    KEY_J: ClassVar[KeyboardInput] = ...
    KEY_K: ClassVar[KeyboardInput] = ...
    KEY_L: ClassVar[KeyboardInput] = ...
    KEY_LEFT: ClassVar[KeyboardInput] = ...
    KEY_LEFT_ALT: ClassVar[KeyboardInput] = ...
    KEY_LEFT_BRACKET: ClassVar[KeyboardInput] = ...
    KEY_LEFT_CONTROL: ClassVar[KeyboardInput] = ...
    KEY_LEFT_SHIFT: ClassVar[KeyboardInput] = ...
    KEY_LEFT_SUPER: ClassVar[KeyboardInput] = ...
    KEY_M: ClassVar[KeyboardInput] = ...
    KEY_MENU: ClassVar[KeyboardInput] = ...
    KEY_MINUS: ClassVar[KeyboardInput] = ...
    KEY_N: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_0: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_1: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_2: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_3: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_4: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_5: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_6: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_7: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_8: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_9: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_ADD: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_DEL: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_DIVIDE: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_ENTER: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_EQUAL: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_MULTIPLY: ClassVar[KeyboardInput] = ...
    KEY_NUMPAD_SUBTRACT: ClassVar[KeyboardInput] = ...
    KEY_NUM_LOCK: ClassVar[KeyboardInput] = ...
    KEY_O: ClassVar[KeyboardInput] = ...
    KEY_P: ClassVar[KeyboardInput] = ...
    KEY_PAGE_DOWN: ClassVar[KeyboardInput] = ...
    KEY_PAGE_UP: ClassVar[KeyboardInput] = ...
    KEY_PAUSE: ClassVar[KeyboardInput] = ...
    KEY_PERIOD: ClassVar[KeyboardInput] = ...
    KEY_PRINT_SCREEN: ClassVar[KeyboardInput] = ...
    KEY_Q: ClassVar[KeyboardInput] = ...
    KEY_R: ClassVar[KeyboardInput] = ...
    KEY_RIGHT: ClassVar[KeyboardInput] = ...
    KEY_RIGHT_ALT: ClassVar[KeyboardInput] = ...
    KEY_RIGHT_BRACKET: ClassVar[KeyboardInput] = ...
    KEY_RIGHT_CONTROL: ClassVar[KeyboardInput] = ...
    KEY_RIGHT_SHIFT: ClassVar[KeyboardInput] = ...
    KEY_RIGHT_SUPER: ClassVar[KeyboardInput] = ...
    KEY_S: ClassVar[KeyboardInput] = ...
    KEY_SCROLL_LOCK: ClassVar[KeyboardInput] = ...
    KEY_SEMICOLON: ClassVar[KeyboardInput] = ...
    KEY_SLASH: ClassVar[KeyboardInput] = ...
    KEY_SPACE: ClassVar[KeyboardInput] = ...
    KEY_T: ClassVar[KeyboardInput] = ...
    KEY_TAB: ClassVar[KeyboardInput] = ...
    KEY_U: ClassVar[KeyboardInput] = ...
    KEY_UP: ClassVar[KeyboardInput] = ...
    KEY_V: ClassVar[KeyboardInput] = ...
    KEY_W: ClassVar[KeyboardInput] = ...
    KEY_X: ClassVar[KeyboardInput] = ...
    KEY_Y: ClassVar[KeyboardInput] = ...
    KEY_Z: ClassVar[KeyboardInput] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    @property
    def name(self) -> str: ...


class Mat33:
    x: Vec3
    y: Vec3
    z: Vec3

    def __init__(self) -> None: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class Mat44:
    w: Quat
    x: Quat
    y: Quat
    z: Quat

    def __init__(self) -> None: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class MeshNormalMode:
    __members__: ClassVar[dict] = ...  # read-only
    COMPUTE_PER_FACE: ClassVar[MeshNormalMode] = ...
    COMPUTE_PER_VERTEX: ClassVar[MeshNormalMode] = ...
    FROM_ASSET: ClassVar[MeshNormalMode] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class MeshType:
    __members__: ClassVar[dict] = ...  # read-only
    MESH_COLLISION: ClassVar[MeshType] = ...
    MESH_NONE: ClassVar[MeshType] = ...
    MESH_VISUAL: ClassVar[MeshType] = ...
    MESH_VISUAL_AND_COLLISION: ClassVar[MeshType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class MouseInput:
    __members__: ClassVar[dict] = ...  # read-only
    MOUSE_BACK_BUTTON: ClassVar[MouseInput] = ...
    MOUSE_FORWARD_BUTTON: ClassVar[MouseInput] = ...
    MOUSE_LEFT_BUTTON: ClassVar[MouseInput] = ...
    MOUSE_MIDDLE_BUTTON: ClassVar[MouseInput] = ...
    MOUSE_MOVE_DOWN: ClassVar[MouseInput] = ...
    MOUSE_MOVE_LEFT: ClassVar[MouseInput] = ...
    MOUSE_MOVE_RIGHT: ClassVar[MouseInput] = ...
    MOUSE_MOVE_UP: ClassVar[MouseInput] = ...
    MOUSE_RIGHT_BUTTON: ClassVar[MouseInput] = ...
    MOUSE_SCROLL_DOWN: ClassVar[MouseInput] = ...
    MOUSE_SCROLL_LEFT: ClassVar[MouseInput] = ...
    MOUSE_SCROLL_RIGHT: ClassVar[MouseInput] = ...
    MOUSE_SCROLL_UP: ClassVar[MouseInput] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    @property
    def name(self) -> str: ...


class OmniConnectionParams:
    enable_cache: bool
    enable_debug_output: bool
    password: str
    server: str
    username: str

    def __init__(self) -> None: ...


class ParticleState:
    dtype: ClassVar[dtype] = ...  # read-only
    normal: Quat
    position: Quat
    velocity: Vec3

    def __init__(self, *args, **kwargs) -> None: ...


class PerformanceTimers:
    frame_idling: float
    graphics_image_retrieval: float
    graphics_sensor_rendering: float
    graphics_viewer_rendering: float
    physics_data_movement: float
    physics_sim: float
    total_time: float

    def __init__(self) -> None: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class PhysXParams:
    always_use_articulations: bool
    bounce_threshold_velocity: float
    contact_collection: ContactCollection
    contact_offset: float
    default_buffer_size_multiplier: float
    friction_correlation_distance: float
    friction_offset_threshold: float
    max_depenetration_velocity: float
    max_gpu_contact_pairs: int
    num_position_iterations: int
    num_subscenes: int
    num_threads: int
    num_velocity_iterations: int
    rest_offset: float
    solver_type: int
    use_gpu: bool

    def __init__(self) -> None: ...


class PlaneParams:
    distance: float
    dynamic_friction: float
    normal: Vec3
    restitution: float
    segmentation_id: int
    static_friction: float

    def __init__(self) -> None: ...


class Quat:
    dtype: ClassVar[dtype] = ...  # read-only
    w: float
    x: float
    y: float
    z: float

    def __init__(self, x: float = ..., y: float = ..., z: float = ..., w: float = ...) -> None: ...

    def from_axis_angle(self, *args, **kwargs) -> Any: ...

    def from_buffer(self, *args, **kwargs) -> Any: ...

    def from_euler_zyx(self, *args, **kwargs) -> Any: ...

    def inverse(self) -> Quat: ...

    def normalize(self) -> Quat: ...

    def rotate(self, arg0: Vec3) -> Vec3: ...

    def to_euler_zyx(self) -> Tuple[float, float, float]: ...

    def __getstate__(self) -> tuple: ...

    def __mul__(self, arg0: Quat) -> Quat: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class RigidBodyProperties:
    com: Vec3
    flags: int
    inertia: Mat33
    invInertia: Mat33
    invMass: float
    mass: float

    def __init__(self) -> None: ...


class RigidBodyState:
    dtype: ClassVar[dtype] = ...  # read-only
    pose: Transform
    vel: Any

    def __init__(self, *args, **kwargs) -> None: ...


class RigidContact:
    def __init__(self) -> None: ...

    @property
    def body0(self) -> int: ...

    @property
    def body1(self) -> int: ...

    @property
    def env0(self) -> int: ...

    @property
    def env1(self) -> int: ...

    @property
    def friction(self) -> float: ...

    @property
    def initial_overlap(self) -> float: ...

    @property
    def lambda(self) -> float: ...

    @property
    def lambda_friction(self) -> Vec2: ...

    @property
    def local_pos0(self) -> Vec3: ...

    @property
    def local_pos1(self) -> Vec3: ...

    @property
    def min_dist(self) -> float: ...

    @property
    def normal(self) -> Vec3: ...

    @property
    def offset0(self) -> Vec3: ...

    @property
    def offset1(self) -> Vec3: ...

    @property
    def rolling_friction(self) -> float: ...

    @property
    def torsion_friction(self) -> float: ...


class RigidShapeProperties:
    compliance: float
    filter: int
    friction: float
    restitution: float
    rolling_friction: float
    thickness: float
    torsion_friction: float

    def __init__(self) -> None: ...


class Sim:
    def __init__(self, *args, **kwargs) -> None: ...


class SimParams:
    dt: float
    enable_actor_creation_warning: bool
    flex: FlexParams
    gravity: Vec3
    num_client_threads: int
    physx: PhysXParams
    stress_visualization: bool
    stress_visualization_max: float
    stress_visualization_min: float
    substeps: int
    up_axis: UpAxis
    use_gpu_pipeline: bool

    def __init__(self) -> None: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class SimType:
    __members__: ClassVar[dict] = ...  # read-only
    SIM_FLEX: ClassVar[SimType] = ...
    SIM_PHYSX: ClassVar[SimType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class SoftContact:
    def __init__(self) -> None: ...

    @property
    def bodyIndex(self) -> int: ...

    @property
    def env0(self) -> int: ...

    @property
    def env1(self) -> int: ...

    @property
    def lambda(self) -> float: ...

    @property
    def normal(self) -> Vec3: ...

    @property
    def particleBarys(self) -> Vec3: ...

    @property
    def particleIndices(self) -> Int3: ...


class SoftMaterial:
    activation: float
    activationMax: float
    damping: float
    model: SoftMaterialType
    poissons: float
    youngs: float

    def __init__(self) -> None: ...


class SoftMaterialType:
    __members__: ClassVar[dict] = ...  # read-only
    MAT_COROTATIONAL: ClassVar[SoftMaterialType] = ...
    MAT_NEOHOOKEAN: ClassVar[SoftMaterialType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class SpatialForce:
    force: Vec3
    torque: Vec3

    def __init__(self) -> None: ...


class TendonProperties:
    damping: float
    fixed_lower_limit: float
    fixed_spring_rest_length: float
    fixed_upper_limit: float
    is_fixed_limited: bool
    limit_stiffness: float
    stiffness: float

    def __init__(self) -> None: ...

    @property
    def num_attachments(self) -> int: ...

    @property
    def num_joints(self) -> int: ...

    @property
    def type(self) -> TendonType: ...


class TendonType:
    __members__: ClassVar[dict] = ...  # read-only
    TENDON_FIXED: ClassVar[TendonType] = ...
    TENDON_SPATIAL: ClassVar[TendonType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    @property
    def name(self) -> str: ...


class Tensor:
    data_address: int
    device: int
    dtype: Any
    own_data: bool
    shape: tuple

    def __init__(self) -> None: ...

    @property
    def data_ptr(self) -> capsule: ...

    @property
    def ndim(self) -> int: ...


class TensorDataType:
    __members__: ClassVar[dict] = ...  # read-only
    DTYPE_FLOAT32: ClassVar[TensorDataType] = ...
    DTYPE_INT16: ClassVar[TensorDataType] = ...
    DTYPE_UINT32: ClassVar[TensorDataType] = ...
    DTYPE_UINT64: ClassVar[TensorDataType] = ...
    DTYPE_UINT8: ClassVar[TensorDataType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class Transform:
    dtype: ClassVar[dtype] = ...  # read-only
    p: Vec3
    r: Quat

    def __init__(self, p: Vec3 = ..., r: Quat = ...) -> None: ...

    def from_buffer(self, *args, **kwargs) -> Any: ...

    def inverse(self) -> Transform: ...

    def transform_point(self, arg0: Vec3) -> Vec3: ...

    def transform_points(self, arg0: numpy.ndarray[Vec3]) -> numpy.ndarray[Vec3]: ...

    def transform_vector(self, arg0: Vec3) -> Vec3: ...

    def transform_vectors(self, arg0: numpy.ndarray[Vec3]) -> numpy.ndarray[Vec3]: ...

    def __getstate__(self) -> tuple: ...

    def __mul__(self, arg0: Transform) -> Transform: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class TriangleMeshParams:
    dynamic_friction: float
    nb_triangles: int
    nb_vertices: int
    restitution: float
    segmentation_id: int
    static_friction: float
    transform: Transform

    def __init__(self) -> None: ...


class UpAxis:
    __members__: ClassVar[dict] = ...  # read-only
    UP_AXIS_Y: ClassVar[UpAxis] = ...
    UP_AXIS_Z: ClassVar[UpAxis] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __and__(self, other) -> Any: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __or__(self, other) -> Any: ...

    def __rand__(self, other) -> Any: ...

    def __ror__(self, other) -> Any: ...

    def __rxor__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    def __xor__(self, other) -> Any: ...

    @property
    def name(self) -> str: ...


class UsdExportOptions:
    export_physics: bool
    material_mode: UsdMaterialMode
    scale: float
    single_file: bool
    use_geom_subsets: bool
    use_physics_visuals: bool

    def __init__(self) -> None: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class UsdExporter:
    def __init__(self, *args, **kwargs) -> None: ...


class UsdMaterialMode:
    __members__: ClassVar[dict] = ...  # read-only
    USD_MATERIAL_DISPLAY_COLOR: ClassVar[UsdMaterialMode] = ...
    USD_MATERIAL_MDL: ClassVar[UsdMaterialMode] = ...
    USD_MATERIAL_PREVIEW_SURFACE: ClassVar[UsdMaterialMode] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, arg0: int) -> None: ...

    def __eq__(self, other) -> Any: ...

    def __ge__(self, other) -> Any: ...

    def __getstate__(self) -> Any: ...

    def __gt__(self, other) -> Any: ...

    def __hash__(self) -> Any: ...

    def __int__(self) -> int: ...

    def __le__(self, other) -> Any: ...

    def __lt__(self, other) -> Any: ...

    def __ne__(self, other) -> Any: ...

    def __setstate__(self, state) -> Any: ...

    @property
    def name(self) -> str: ...


class Vec2:
    dtype: ClassVar[dtype] = ...  # read-only
    x: float
    y: float

    def __init__(self, x: float = ..., y: float = ...) -> None: ...

    def from_buffer(self, *args, **kwargs) -> Any: ...

    def __add__(self, arg0: Vec2) -> Vec2: ...

    def __getstate__(self) -> tuple: ...

    def __mul__(self, arg0: float) -> Vec2: ...

    def __neg__(self) -> Vec2: ...

    def __setstate__(self, arg0: tuple) -> None: ...

    def __sub__(self, arg0: Vec2) -> Vec2: ...

    def __truediv__(self, arg0: float) -> Vec2: ...


class Vec3:
    dtype: ClassVar[dtype] = ...  # read-only
    x: float
    y: float
    z: float

    def __init__(self, x: float = ..., y: float = ..., z: float = ...) -> None: ...

    def cross(self, arg0: Vec3) -> Vec3: ...

    def dot(self, arg0: Vec3) -> float: ...

    def from_buffer(self, *args, **kwargs) -> Any: ...

    def length(self) -> float: ...

    def length_sq(self) -> float: ...

    def normalize(self) -> Vec3: ...

    def __add__(self, arg0: Vec3) -> Vec3: ...

    def __getstate__(self) -> tuple: ...

    def __mul__(self, arg0: float) -> Vec3: ...

    def __neg__(self) -> Vec3: ...

    def __setstate__(self, arg0: tuple) -> None: ...

    def __sub__(self, arg0: Vec3) -> Vec3: ...

    def __truediv__(self, arg0: float) -> Vec3: ...


class Velocity:
    dtype: ClassVar[dtype] = ...  # read-only
    angular: Vec3
    linear: Vec3

    def __init__(self, p: Vec3 = ..., q: Vec3 = ...) -> None: ...

    def from_buffer(self, *args, **kwargs) -> Any: ...

    def __getstate__(self) -> tuple: ...

    def __setstate__(self, arg0: tuple) -> None: ...


class Version:
    major: int
    minor: int

    def __init__(self) -> None: ...


class VhacdParams:
    alpha: float
    beta: float
    concavity: float
    convex_hull_approximation: bool
    convex_hull_downsampling: int
    max_convex_hulls: int
    max_num_vertices_per_ch: int
    min_volume_per_ch: float
    mode: 0
    ocl_acceleration: bool
    pca: int
    plane_downsampling: int
    project_hull_vertices: bool
    resolution: int

    def __init__(self) -> None: ...


class Viewer:
    def __init__(self, *args, **kwargs) -> None: ...


def acquire_gym(*args, **kwargs) -> Any: ...


def carb_init(config_str: str = ...) -> bool: ...


def cross(*args, **kwargs) -> Any: ...


@overload
def dot(arg0, arg1) -> numpy.ndarray[numpy.float32]: ...


@overload
def dot(arg0, arg1) -> numpy.ndarray[numpy.float32]: ...


def eulers_to_quats_zyx(*args, **kwargs) -> Any: ...


def quats_to_eulers_zyx(*args, **kwargs) -> Any: ...


def rotate(*args, **kwargs) -> Any: ...


def rotate_inverse(*args, **kwargs) -> Any: ...


def transform(*args, **kwargs) -> Any: ...


def transform_inverse(*args, **kwargs) -> Any: ...
